//
//  index.swift
//  ElasticSwift
//
//  Created by Prafull Kumar Soni on 5/30/17.
//
//

import ElasticSwiftCore
import Foundation
import NIOHTTP1

// MARK: - Index Requet Builder

public class IndexRequestBuilder<T: Codable>: RequestBuilder where T: Equatable {
    public typealias RequestType = IndexRequest<T>

    private var _index: String?
    private var _type: String?
    private var _id: String?
    private var _source: T?
    private var _routing: String?
    private var _parent: String?
    private var _version: String?
    private var _versionType: VersionType?
    private var _refresh: IndexRefresh?

    public init() {}

    @discardableResult
    public func set(index: String) -> Self {
        _index = index
        return self
    }

    @discardableResult
    @available(*, deprecated, message: "Elasticsearch has deprecated use of custom types and will be remove in 7.0")
    public func set(type: String) -> Self {
        _type = type
        return self
    }

    @discardableResult
    public func set(id: String) -> Self {
        _id = id
        return self
    }

    @discardableResult
    public func set(routing: String) -> Self {
        _routing = routing
        return self
    }

    @discardableResult
    public func set(parent: String) -> Self {
        _parent = parent
        return self
    }

    @discardableResult
    public func set(source: T) -> Self {
        _source = source
        return self
    }

    @discardableResult
    public func set(version: String) -> Self {
        _version = version
        return self
    }

    @discardableResult
    public func set(versionType: VersionType) -> Self {
        _versionType = versionType
        return self
    }

    @discardableResult
    public func set(refresh: IndexRefresh) -> Self {
        _refresh = refresh
        return self
    }

    public var index: String? {
        return _index
    }

    public var type: String? {
        return _type
    }

    public var id: String? {
        return _id
    }

    public var source: T? {
        return _source
    }

    public var routing: String? {
        return _routing
    }

    public var parent: String? {
        return _parent
    }

    public var version: String? {
        return _version
    }

    public var versionType: VersionType? {
        return _versionType
    }

    public var refresh: IndexRefresh? {
        return _refresh
    }

    public func build() throws -> IndexRequest<T> {
        return try IndexRequest<T>(withBuilder: self)
    }
}

// MARK: - Index Request

public struct IndexRequest<T: Codable>: Request, BulkableRequest where T: Equatable {
    public var headers = HTTPHeaders()

    public var method: HTTPMethod {
        if id == "ID WILL BE GENERATED BY ELASTICSEARCH" {
            return .POST
        }
        return .PUT
    }

    public let index: String
    public let type: String
    public let id: String
    public let source: T
    public var opType: OpType = .index
    public var routing: String?
    public var parent: String?
    public var version: String?
    public var versionType: VersionType?
    public var refresh: IndexRefresh?

    public init(index: String, type: String = "_doc", id: String?, source: T) {
        self.index = index
        self.type = type
        self.id = id ?? "ID WILL BE GENERATED BY ELASTICSEARCH"
        self.source = source
    }

    public init(index: String, type: String = "_doc", id: String?, source: T, routing: String?, parent: String?, refresh: IndexRefresh?, version: String, versionType: VersionType) {
        self.init(index: index, type: type, id: id, source: source)

        self.routing = routing
        self.parent = parent
        self.refresh = refresh
        self.version = version
        self.versionType = versionType
    }

    internal init(withBuilder builder: IndexRequestBuilder<T>) throws {
        guard builder.index != nil else {
            throw RequestBuilderError.missingRequiredField("index")
        }

        guard builder.source != nil else {
            throw RequestBuilderError.missingRequiredField("source")
        }

        guard (builder.version != nil && builder.versionType != nil) || (builder.version == nil && builder.versionType == nil) else {
            throw RequestBuilderError.missingRequiredField("source")
        }

        self.init(index: builder.index!, type: builder.type ?? "_doc", id: builder.id, source: builder.source!)

        routing = builder.routing
        parent = builder.parent
        version = builder.version
        versionType = builder.versionType
        refresh = builder.refresh
    }

    public var endPoint: String {
        var _endPoint = index + "/" + type
        if id != "ID WILL BE GENERATED BY ELASTICSEARCH" {
            _endPoint = _endPoint + "/" + id
        }
        return _endPoint
    }

    public func makeBody(_ serializer: Serializer) -> Result<Data, MakeBodyError> {
        return serializer.encode(source).flatMapError { error in .failure(.wrapped(error)) }
    }

    public var queryParams: [URLQueryItem] {
        var queryItems = [URLQueryItem]()
        if let routing = self.routing {
            queryItems.append(URLQueryItem(name: QueryParams.routing.rawValue, value: routing))
        }
        if let version = self.version, let versionType = self.versionType {
            queryItems.append(URLQueryItem(name: QueryParams.version, value: version))
            queryItems.append(URLQueryItem(name: QueryParams.versionType, value: versionType.rawValue))
        }
        if let refresh = self.refresh {
            queryItems.append(URLQueryItem(name: QueryParams.refresh, value: refresh.rawValue))
        }
        if let parentId = parent {
            queryItems.append(URLQueryItem(name: QueryParams.parent, value: parentId))
        }

        queryItems.append(URLQueryItem(name: QueryParams.opType, value: opType.rawValue))

        return queryItems
    }
}

extension IndexRequest: Equatable {}
